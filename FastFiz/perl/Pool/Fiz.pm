# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Pool::Fiz;
use base qw(Exporter);
use base qw(DynaLoader);
package Pool::Fizc;
bootstrap Pool::Fiz;
package Pool::Fiz;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Pool::Fiz;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Pool::Fiz;

*getFastFizVersion = *Pool::Fizc::getFastFizVersion;
*getTestState = *Pool::Fizc::getTestState;
*getTestShotParams = *Pool::Fizc::getTestShotParams;

############# Class : Pool::Fiz::ShotParams ##############

package Pool::Fiz::ShotParams;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*swig_a_get = *Pool::Fizc::ShotParams_a_get;
*swig_a_set = *Pool::Fizc::ShotParams_a_set;
*swig_b_get = *Pool::Fizc::ShotParams_b_get;
*swig_b_set = *Pool::Fizc::ShotParams_b_set;
*swig_theta_get = *Pool::Fizc::ShotParams_theta_get;
*swig_theta_set = *Pool::Fizc::ShotParams_theta_set;
*swig_phi_get = *Pool::Fizc::ShotParams_phi_get;
*swig_phi_set = *Pool::Fizc::ShotParams_phi_set;
*swig_v_get = *Pool::Fizc::ShotParams_v_get;
*swig_v_set = *Pool::Fizc::ShotParams_v_set;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_ShotParams(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_ShotParams($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Point ##############

package Pool::Fiz::Point;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *Pool::Fizc::Point_x_get;
*swig_x_set = *Pool::Fizc::Point_x_set;
*swig_y_get = *Pool::Fizc::Point_y_get;
*swig_y_set = *Pool::Fizc::Point_y_set;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_Point(@_);
    bless $self, $pkg if defined($self);
}

*toString = *Pool::Fizc::Point_toString;
*fromString = *Pool::Fizc::Point_fromString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Point($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Vector ##############

package Pool::Fiz::Vector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *Pool::Fizc::Vector_x_get;
*swig_x_set = *Pool::Fizc::Vector_x_set;
*swig_y_get = *Pool::Fizc::Vector_y_get;
*swig_y_set = *Pool::Fizc::Vector_y_set;
*swig_z_get = *Pool::Fizc::Vector_z_get;
*swig_z_set = *Pool::Fizc::Vector_z_set;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_Vector(@_);
    bless $self, $pkg if defined($self);
}

*toString = *Pool::Fizc::Vector_toString;
*fromString = *Pool::Fizc::Vector_fromString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Vector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Ball ##############

package Pool::Fiz::Ball;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*NOTINPLAY = *Pool::Fizc::Ball_NOTINPLAY;
*STATIONARY = *Pool::Fizc::Ball_STATIONARY;
*SPINNING = *Pool::Fizc::Ball_SPINNING;
*SLIDING = *Pool::Fizc::Ball_SLIDING;
*ROLLING = *Pool::Fizc::Ball_ROLLING;
*POCKETED_SW = *Pool::Fizc::Ball_POCKETED_SW;
*POCKETED_W = *Pool::Fizc::Ball_POCKETED_W;
*POCKETED_NW = *Pool::Fizc::Ball_POCKETED_NW;
*POCKETED_NE = *Pool::Fizc::Ball_POCKETED_NE;
*POCKETED_E = *Pool::Fizc::Ball_POCKETED_E;
*POCKETED_SE = *Pool::Fizc::Ball_POCKETED_SE;
*SLIDING_SPINNING = *Pool::Fizc::Ball_SLIDING_SPINNING;
*ROLLING_SPINNING = *Pool::Fizc::Ball_ROLLING_SPINNING;
*UNKNOWN_STATE = *Pool::Fizc::Ball_UNKNOWN_STATE;
*CUE = *Pool::Fizc::Ball_CUE;
*ONE = *Pool::Fizc::Ball_ONE;
*TWO = *Pool::Fizc::Ball_TWO;
*THREE = *Pool::Fizc::Ball_THREE;
*FOUR = *Pool::Fizc::Ball_FOUR;
*FIVE = *Pool::Fizc::Ball_FIVE;
*SIX = *Pool::Fizc::Ball_SIX;
*SEVEN = *Pool::Fizc::Ball_SEVEN;
*EIGHT = *Pool::Fizc::Ball_EIGHT;
*NINE = *Pool::Fizc::Ball_NINE;
*TEN = *Pool::Fizc::Ball_TEN;
*ELEVEN = *Pool::Fizc::Ball_ELEVEN;
*TWELVE = *Pool::Fizc::Ball_TWELVE;
*THIRTEEN = *Pool::Fizc::Ball_THIRTEEN;
*FOURTEEN = *Pool::Fizc::Ball_FOURTEEN;
*FIFTEEN = *Pool::Fizc::Ball_FIFTEEN;
*UNKNOWN_ID = *Pool::Fizc::Ball_UNKNOWN_ID;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_Ball(@_);
    bless $self, $pkg if defined($self);
}

*getRadius = *Pool::Fizc::Ball_getRadius;
*getID = *Pool::Fizc::Ball_getID;
*getIDString = *Pool::Fizc::Ball_getIDString;
*getState = *Pool::Fizc::Ball_getState;
*getStateString = *Pool::Fizc::Ball_getStateString;
*getPos = *Pool::Fizc::Ball_getPos;
*getVelocity = *Pool::Fizc::Ball_getVelocity;
*getSpin = *Pool::Fizc::Ball_getSpin;
*setID = *Pool::Fizc::Ball_setID;
*setPos = *Pool::Fizc::Ball_setPos;
*setVelocity = *Pool::Fizc::Ball_setVelocity;
*setSpin = *Pool::Fizc::Ball_setSpin;
*setState = *Pool::Fizc::Ball_setState;
*isInPlay = *Pool::Fizc::Ball_isInPlay;
*isPocketed = *Pool::Fizc::Ball_isPocketed;
*updateState = *Pool::Fizc::Ball_updateState;
*toString = *Pool::Fizc::Ball_toString;
*fromString = *Pool::Fizc::Ball_fromString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Ball($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Table ##############

package Pool::Fiz::Table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*g = *Pool::Fizc::Table_g;
*g = *Pool::Fizc::Table_g;
*MU_SLIDING = *Pool::Fizc::Table_MU_SLIDING;
*MU_SLIDING = *Pool::Fizc::Table_MU_SLIDING;
*MU_ROLLING = *Pool::Fizc::Table_MU_ROLLING;
*MU_ROLLING = *Pool::Fizc::Table_MU_ROLLING;
*MU_SPINNING = *Pool::Fizc::Table_MU_SPINNING;
*MU_SPINNING = *Pool::Fizc::Table_MU_SPINNING;
*TABLE_LENGTH = *Pool::Fizc::Table_TABLE_LENGTH;
*TABLE_LENGTH = *Pool::Fizc::Table_TABLE_LENGTH;
*TABLE_WIDTH = *Pool::Fizc::Table_TABLE_WIDTH;
*TABLE_WIDTH = *Pool::Fizc::Table_TABLE_WIDTH;
*CORNER_POCKET_WIDTH = *Pool::Fizc::Table_CORNER_POCKET_WIDTH;
*CORNER_POCKET_WIDTH = *Pool::Fizc::Table_CORNER_POCKET_WIDTH;
*SIDE_POCKET_WIDTH = *Pool::Fizc::Table_SIDE_POCKET_WIDTH;
*SIDE_POCKET_WIDTH = *Pool::Fizc::Table_SIDE_POCKET_WIDTH;
*RAIL_HEIGHT = *Pool::Fizc::Table_RAIL_HEIGHT;
*RAIL_HEIGHT = *Pool::Fizc::Table_RAIL_HEIGHT;
*CUE_LENGTH = *Pool::Fizc::Table_CUE_LENGTH;
*CUE_LENGTH = *Pool::Fizc::Table_CUE_LENGTH;
*RAIL_VEL_DAMPING_X = *Pool::Fizc::Table_RAIL_VEL_DAMPING_X;
*RAIL_VEL_DAMPING_X = *Pool::Fizc::Table_RAIL_VEL_DAMPING_X;
*RAIL_VEL_DAMPING_Y = *Pool::Fizc::Table_RAIL_VEL_DAMPING_Y;
*RAIL_VEL_DAMPING_Y = *Pool::Fizc::Table_RAIL_VEL_DAMPING_Y;
*RAIL_SPIN_DAMPING = *Pool::Fizc::Table_RAIL_SPIN_DAMPING;
*RAIL_SPIN_DAMPING = *Pool::Fizc::Table_RAIL_SPIN_DAMPING;
*RAIL_VEL_ANGLE_ADJ = *Pool::Fizc::Table_RAIL_VEL_ANGLE_ADJ;
*RAIL_VEL_ANGLE_ADJ = *Pool::Fizc::Table_RAIL_VEL_ANGLE_ADJ;
*RAIL_ZSPIN_ANGLE_ADJ = *Pool::Fizc::Table_RAIL_ZSPIN_ANGLE_ADJ;
*RAIL_ZSPIN_ANGLE_ADJ = *Pool::Fizc::Table_RAIL_ZSPIN_ANGLE_ADJ;
*CUE_MASS = *Pool::Fizc::Table_CUE_MASS;
*CUE_MASS = *Pool::Fizc::Table_CUE_MASS;
*I = *Pool::Fizc::Table_I;
*I = *Pool::Fizc::Table_I;
*SW_POCKET = *Pool::Fizc::Table_SW_POCKET;
*SW_RAIL = *Pool::Fizc::Table_SW_RAIL;
*W_POCKET = *Pool::Fizc::Table_W_POCKET;
*NW_RAIL = *Pool::Fizc::Table_NW_RAIL;
*NW_POCKET = *Pool::Fizc::Table_NW_POCKET;
*N_RAIL = *Pool::Fizc::Table_N_RAIL;
*NE_POCKET = *Pool::Fizc::Table_NE_POCKET;
*NE_RAIL = *Pool::Fizc::Table_NE_RAIL;
*E_POCKET = *Pool::Fizc::Table_E_POCKET;
*SE_RAIL = *Pool::Fizc::Table_SE_RAIL;
*SE_POCKET = *Pool::Fizc::Table_SE_POCKET;
*S_RAIL = *Pool::Fizc::Table_S_RAIL;
*UNKNOWN_BOUNDARY = *Pool::Fizc::Table_UNKNOWN_BOUNDARY;
*SW = *Pool::Fizc::Table_SW;
*W = *Pool::Fizc::Table_W;
*NW = *Pool::Fizc::Table_NW;
*NE = *Pool::Fizc::Table_NE;
*E = *Pool::Fizc::Table_E;
*SE = *Pool::Fizc::Table_SE;
*UNKNOWN_POCKET = *Pool::Fizc::Table_UNKNOWN_POCKET;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_Table(@_);
    bless $self, $pkg if defined($self);
}

*getLength = *Pool::Fizc::Table_getLength;
*getWidth = *Pool::Fizc::Table_getWidth;
*getHeadString = *Pool::Fizc::Table_getHeadString;
*getFootSpot = *Pool::Fizc::Table_getFootSpot;
*setCueLength = *Pool::Fizc::Table_setCueLength;
*getCueLength = *Pool::Fizc::Table_getCueLength;
*setRailHeight = *Pool::Fizc::Table_setRailHeight;
*getRailHeight = *Pool::Fizc::Table_getRailHeight;
*setMuSliding = *Pool::Fizc::Table_setMuSliding;
*getMuSliding = *Pool::Fizc::Table_getMuSliding;
*setMuRolling = *Pool::Fizc::Table_setMuRolling;
*getMuRolling = *Pool::Fizc::Table_getMuRolling;
*setMuSpinning = *Pool::Fizc::Table_setMuSpinning;
*getMuSpinning = *Pool::Fizc::Table_getMuSpinning;
*getPocketCenter = *Pool::Fizc::Table_getPocketCenter;
*getPocketRight = *Pool::Fizc::Table_getPocketRight;
*getPocketLeft = *Pool::Fizc::Table_getPocketLeft;
*defaultTable = *Pool::Fizc::Table_defaultTable;
*stateFromPocket = *Pool::Fizc::Table_stateFromPocket;
*pocketFromBndId = *Pool::Fizc::Table_pocketFromBndId;
*bndIdFromPocket = *Pool::Fizc::Table_bndIdFromPocket;
*boundaryName = *Pool::Fizc::Table_boundaryName;
*pocketName = *Pool::Fizc::Table_pocketName;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Event ##############

package Pool::Fiz::Event;
use overload
    "<" => sub { $_[0]->__lt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*NO_EVENT = *Pool::Fizc::Event_NO_EVENT;
*STATE_CHANGE = *Pool::Fizc::Event_STATE_CHANGE;
*BALL_COLLISION = *Pool::Fizc::Event_BALL_COLLISION;
*RAIL_COLLISION = *Pool::Fizc::Event_RAIL_COLLISION;
*POCKETED = *Pool::Fizc::Event_POCKETED;
*CUE_STRIKE = *Pool::Fizc::Event_CUE_STRIKE;
*MISCUE = *Pool::Fizc::Event_MISCUE;
*UNKNOWN_EVENT = *Pool::Fizc::Event_UNKNOWN_EVENT;
*getTime = *Pool::Fizc::Event_getTime;
*getBall1 = *Pool::Fizc::Event_getBall1;
*getBall1Data = *Pool::Fizc::Event_getBall1Data;
*__lt__ = *Pool::Fizc::Event___lt__;
*eventCmp = *Pool::Fizc::Event_eventCmp;
*toString = *Pool::Fizc::Event_toString;
*getType = *Pool::Fizc::Event_getType;
*getTypeString = *Pool::Fizc::Event_getTypeString;
*getBall2 = *Pool::Fizc::Event_getBall2;
*getBall2Data = *Pool::Fizc::Event_getBall2Data;
*relatedTo = *Pool::Fizc::Event_relatedTo;
*involvesBall = *Pool::Fizc::Event_involvesBall;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Event($self);
        delete $OWNER{$self};
    }
}

*handle = *Pool::Fizc::Event_handle;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::StateChangeEvent ##############

package Pool::Fiz::StateChangeEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz::Event Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_StateChangeEvent(@_);
    bless $self, $pkg if defined($self);
}

*getType = *Pool::Fizc::StateChangeEvent_getType;
*getTypeString = *Pool::Fizc::StateChangeEvent_getTypeString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_StateChangeEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::BallCollisionEvent ##############

package Pool::Fiz::BallCollisionEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz::Event Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_BallCollisionEvent(@_);
    bless $self, $pkg if defined($self);
}

*getType = *Pool::Fizc::BallCollisionEvent_getType;
*getTypeString = *Pool::Fizc::BallCollisionEvent_getTypeString;
*relatedTo = *Pool::Fizc::BallCollisionEvent_relatedTo;
*involvesBall = *Pool::Fizc::BallCollisionEvent_involvesBall;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_BallCollisionEvent($self);
        delete $OWNER{$self};
    }
}

*getBall2 = *Pool::Fizc::BallCollisionEvent_getBall2;
*getBall2Data = *Pool::Fizc::BallCollisionEvent_getBall2Data;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::RailCollisionEvent ##############

package Pool::Fiz::RailCollisionEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz::Event Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_RailCollisionEvent(@_);
    bless $self, $pkg if defined($self);
}

*getType = *Pool::Fizc::RailCollisionEvent_getType;
*getTypeString = *Pool::Fizc::RailCollisionEvent_getTypeString;
*getRail = *Pool::Fizc::RailCollisionEvent_getRail;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_RailCollisionEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::PocketedEvent ##############

package Pool::Fiz::PocketedEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz::Event Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_PocketedEvent(@_);
    bless $self, $pkg if defined($self);
}

*getType = *Pool::Fizc::PocketedEvent_getType;
*getTypeString = *Pool::Fizc::PocketedEvent_getTypeString;
*getPocket = *Pool::Fizc::PocketedEvent_getPocket;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_PocketedEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::CueStrikeEvent ##############

package Pool::Fiz::CueStrikeEvent;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz::Event Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_CueStrikeEvent(@_);
    bless $self, $pkg if defined($self);
}

*getType = *Pool::Fizc::CueStrikeEvent_getType;
*getTypeString = *Pool::Fizc::CueStrikeEvent_getTypeString;
*getParams = *Pool::Fizc::CueStrikeEvent_getParams;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_CueStrikeEvent($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Shot ##############

package Pool::Fiz::Shot;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*getEventList = *Pool::Fizc::Shot_getEventList;
*getDuration = *Pool::Fizc::Shot_getDuration;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Shot($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::TableState ##############

package Pool::Fiz::TableState;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*MAX_VELOCITY = *Pool::Fizc::TableState_MAX_VELOCITY;
*MAX_VELOCITY = *Pool::Fizc::TableState_MAX_VELOCITY;
*MIN_THETA = *Pool::Fizc::TableState_MIN_THETA;
*MIN_THETA = *Pool::Fizc::TableState_MIN_THETA;
*MAX_THETA = *Pool::Fizc::TableState_MAX_THETA;
*MAX_THETA = *Pool::Fizc::TableState_MAX_THETA;
*OK_PRECONDITION = *Pool::Fizc::TableState_OK_PRECONDITION;
*OK_PRECONDITION = *Pool::Fizc::TableState_OK_PRECONDITION;
*BAD_A_VAL = *Pool::Fizc::TableState_BAD_A_VAL;
*BAD_A_VAL = *Pool::Fizc::TableState_BAD_A_VAL;
*BAD_B_VAL = *Pool::Fizc::TableState_BAD_B_VAL;
*BAD_B_VAL = *Pool::Fizc::TableState_BAD_B_VAL;
*BAD_THETA_VAL = *Pool::Fizc::TableState_BAD_THETA_VAL;
*BAD_THETA_VAL = *Pool::Fizc::TableState_BAD_THETA_VAL;
*BAD_PHI_VAL = *Pool::Fizc::TableState_BAD_PHI_VAL;
*BAD_PHI_VAL = *Pool::Fizc::TableState_BAD_PHI_VAL;
*BAD_V_VAL = *Pool::Fizc::TableState_BAD_V_VAL;
*BAD_V_VAL = *Pool::Fizc::TableState_BAD_V_VAL;
*BAD_X_VAL = *Pool::Fizc::TableState_BAD_X_VAL;
*BAD_X_VAL = *Pool::Fizc::TableState_BAD_X_VAL;
*BAD_Y_VAL = *Pool::Fizc::TableState_BAD_Y_VAL;
*BAD_Y_VAL = *Pool::Fizc::TableState_BAD_Y_VAL;
*CUE_STICK_COLLISION = *Pool::Fizc::TableState_CUE_STICK_COLLISION;
*CUE_STICK_COLLISION = *Pool::Fizc::TableState_CUE_STICK_COLLISION;
*BALL_OVERLAP = *Pool::Fizc::TableState_BALL_OVERLAP;
*BALL_OVERLAP = *Pool::Fizc::TableState_BALL_OVERLAP;
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_TableState(@_);
    bless $self, $pkg if defined($self);
}

*getNumBalls = *Pool::Fizc::TableState_getNumBalls;
*setBall = *Pool::Fizc::TableState_setBall;
*spotBall = *Pool::Fizc::TableState_spotBall;
*getBall = *Pool::Fizc::TableState_getBall;
*getTable = *Pool::Fizc::TableState_getTable;
*isValidBallPlacement = *Pool::Fizc::TableState_isValidBallPlacement;
*isPhysicallyPossible = *Pool::Fizc::TableState_isPhysicallyPossible;
*addNoise = *Pool::Fizc::TableState_addNoise;
*executeShot = *Pool::Fizc::TableState_executeShot;
*getFirstBallHit = *Pool::Fizc::TableState_getFirstBallHit;
*toString = *Pool::Fizc::TableState_toString;
*fromString = *Pool::Fizc::TableState_fromString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_TableState($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::EventVector ##############

package Pool::Fiz::EventVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Pool::Fizc::new_EventVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *Pool::Fizc::EventVector_size;
*empty = *Pool::Fizc::EventVector_empty;
*clear = *Pool::Fizc::EventVector_clear;
*push = *Pool::Fizc::EventVector_push;
*pop = *Pool::Fizc::EventVector_pop;
*get = *Pool::Fizc::EventVector_get;
*set = *Pool::Fizc::EventVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_EventVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Pool::Fiz::Noise ##############

package Pool::Fiz::Noise;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Pool::Fiz );
%OWNER = ();
%ITERATORS = ();
*Factory = *Pool::Fizc::Noise_Factory;
*toString = *Pool::Fizc::Noise_toString;
*noiseType = *Pool::Fizc::Noise_noiseType;
*applyNoise = *Pool::Fizc::Noise_applyNoise;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Pool::Fizc::delete_Noise($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Pool::Fiz;

*NT_UNDEFINED = *Pool::Fizc::NT_UNDEFINED;
*NT_NONE = *Pool::Fizc::NT_NONE;
*NT_GAUSSIAN = *Pool::Fizc::NT_GAUSSIAN;
1;
